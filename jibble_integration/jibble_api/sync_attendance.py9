import requests
import frappe
from datetime import datetime
import pytz

local_tz = pytz.timezone('Africa/Cairo')  # Set timezone

# Function to get the access token
def get_access_token():
    url = 'https://identity.prod.jibble.io/connect/token'
    headers = {'Accept': 'application/json', 'Content-Type': 'application/x-www-form-urlencoded'}
    data = {
        'grant_type': 'client_credentials',
        'client_id': 'e70b5bab-4de8-4b37-845e-1ec47cb2dd03',
        'client_secret': 'lSNkMwc-A7qrdR7Fo0GAB1jkwOiCsQhCxrfID4rJFYVi86Io'
    }
    response = requests.post(url, headers=headers, data=data)
    if response.status_code == 200:
        return response.json().get('access_token')
    else:
        frappe.log_error(f"Failed to get access token: {response.text[:100]}...", "Jibble API Error")
        return None

# Function to fetch employees from Jibble API
def fetch_employees():
    token = get_access_token()
    if not token:
        return []

    url = 'https://workspace.prod.jibble.io/v1/People'
    headers = {'Authorization': f'Bearer {token}'}
    response = requests.get(url, headers=headers)

    if response.status_code == 200:
        return response.json().get('value', [])
    else:
        frappe.log_error(f"Failed to fetch employees: {response.text[:100]}...", "Jibble API Error")
        return []

# Function to fetch locations from Jibble API
def fetch_locations():
    token = get_access_token()
    if not token:
        return []

    url = 'https://workspace.prod.jibble.io/v1/Locations?%24filter=status%20ne%20%27Archived%27&%24select=id,name,code,address,geoFence,coordinates'
    headers = {'Authorization': f'Bearer {token}'}
    response = requests.get(url, headers=headers)

    if response.status_code == 200:
        return response.json().get('value', [])
    else:
        frappe.log_error(f"Failed to fetch locations: {response.text[:100]}...", "Jibble API Error")
        return []

# Function to create a location dictionary for quick lookup
def create_location_dict(locations):
    return {loc['id']: loc['coordinates'] for loc in locations if loc.get('coordinates')}

# Function to parse timestamps safely
def parse_timestamp(timestamp):
    try:
        if '.' in timestamp:
            timestamp = timestamp.split('.')[0]  # Remove milliseconds
        if 'Z' in timestamp:
            timestamp = timestamp.replace('Z', '')  # Remove 'Z' indicating UTC
        dt_utc = datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S').replace(tzinfo=pytz.UTC)
        return dt_utc
    except ValueError as e:
        frappe.log_error(f"Invalid timestamp {timestamp}: {e}", "Jibble Timestamp Error")
        return None

# Function to fetch attendance data from Jibble API
def fetch_attendance_data_for_day(date):
    token = get_access_token()
    if not token:
        return []

    url = f'https://time-tracking.prod.jibble.io/v1/TimeEntries?$count=true&$expand=person($select=id,fullname)&$filter=(belongsToDate eq {date} and status ne \'Archived\')&$orderby=time asc'
    headers = {'Authorization': f'Bearer {token}', 'Accept': 'application/json', 'Content-Type': 'application/json'}
    response = requests.get(url, headers=headers)

    if response.status_code == 200:
        return response.json().get('value', [])
    else:
        frappe.log_error(f"Failed to fetch attendance data: {response.text[:100]}...", "Jibble API Error")
        return []

# Function to fetch employee emails from Frappe
def fetch_employees_from_frappe():
    employee_list = frappe.get_all('Employee', fields=['employee_name', 'user_id'])
    email_dict = {emp['employee_name'].strip().lower(): emp['user_id'] for emp in employee_list if emp['user_id']}

    # Manual fallback for missing users
    manual_emails = {
        'mahmoud abdelghaffar': 'mahmoud.abdelghaffar@pharaonx.com',
        'mostafa taha amer': 'mostafa.taha@pharaonx.com',
        'mahmoud halool': 'mahmoud.halool@pharaonx.com',
        'ahmed rashid': 'ahmed.rashid@pharaonx.com'
    }

    # Merge manual emails directly into email_dict
    for name, email in manual_emails.items():
        email_dict[name] = email  # Always override to ensure manual emails are set

    return email_dict

# Function to create or update Attendance for an employee
def create_or_update_attendance(employee_name, attendance_date):
    existing_attendance = frappe.get_all(
        'Attendance',
        filters={'employee': employee_name, 'attendance_date': attendance_date},
        fields=['name']
    )

    if existing_attendance:
        return frappe.get_doc('Attendance', existing_attendance[0]['name'])  # Return existing attendance record

    attendance_doc = frappe.get_doc({
        'doctype': 'Attendance',
        'employee': employee_name,
        'attendance_date': attendance_date,
        'status': 'Present'
    })
    attendance_doc.insert(ignore_permissions=True)
    frappe.db.commit()

    return attendance_doc

# Function to create Check-in/Check-out log linked to Attendance
def create_checkin_or_checkout(employee_id, employee_name, timestamp, log_type, attendance_doc, working_hour, location, email):
    dt_utc = parse_timestamp(timestamp)
    if not dt_utc:
        return None

    dt_local = dt_utc.astimezone(local_tz)
    formatted_time = dt_local.strftime('%Y-%m-%d %H:%M:%S')

    # Ensure location is retained from check-in if missing during check-out
    if not location and log_type.upper() == "OUT":
        last_checkin = frappe.get_all(
            'Employee Checkin',
            filters={'employee': employee_name, 'log_type': 'IN'},
            order_by="time desc",
            fields=['latitude', 'longitude'],
            limit=1
        )
        if last_checkin:
            location = {"latitude": last_checkin[0]['latitude'], "longitude": last_checkin[0]['longitude']}

    if not location:
        location = {"latitude": 29.9677640, "longitude": 31.2508160}

    existing_log = frappe.get_all(
        'Employee Checkin',
        filters={'employee': employee_name, 'time': formatted_time, 'log_type': log_type},
        fields=['name']
    )

    if existing_log:
        return None

    new_log = frappe.get_doc({
        'doctype': 'Employee Checkin',
        'employee': employee_name,
        'time': formatted_time,
        'log_type': log_type.upper(),
        'working_hour': working_hour,
        'latitude': location.get('latitude', 29.9677640),
        'longitude': location.get('longitude', 31.2508160),
        'employee_email': email,  # âœ… Always set the email (manual or fetched)
        'attendance': attendance_doc.name if attendance_doc else None
    })
    new_log.insert(ignore_permissions=True)
    frappe.db.commit()

    return new_log

# Main function to process attendance data
def process_and_store_data():
    email_dict = fetch_employees_from_frappe()
    locations = fetch_locations()
    location_dict = create_location_dict(locations)

    date_today = datetime.today().strftime('%Y-%m-%d')
    attendance_data = fetch_attendance_data_for_day(date_today)

    last_check_in = {}

    for entry in attendance_data:
        employee_name = entry["person"]["fullName"].strip().lower()
        person_id = entry["person"]["id"]
        log_type = entry["type"]
        timestamp = entry["time"]

        location_id = entry.get('locationId')
        location = location_dict.get(location_id, None)

        email = email_dict.get(employee_name)

        attendance_doc = create_or_update_attendance(employee_name, date_today)

        working_hour = 0  

        create_checkin_or_checkout(person_id, employee_name, timestamp, log_type, attendance_doc, working_hour, location, email)

process_and_store_data()
	
